<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>AOE4 Team Tool</title>
    <style>
        html,body{height:100%;margin:0;font-family:Segoe UI,Arial,sans-serif}
        .container{display:grid;grid-template-columns:repeat(4,1fr);gap:12px;padding:12px;height:100vh;box-sizing:border-box}
        .panel{background:#f7f7f8;border:1px solid #ddd;border-radius:6px;padding:12px;display:flex;flex-direction:column}
        .panel h2{margin:0 0 8px 0;font-size:16px}
        ul{list-style:none;padding:0;margin:0;overflow:auto}
        li{padding:6px 8px;border-radius:4px;margin-bottom:6px;background:#fff;border:1px solid #e6e6e6;display:flex;justify-content:space-between;align-items:center}
        .controls{display:flex;gap:6px;margin-bottom:8px}
        input[type=number]{width:100px}
        button{padding:6px 8px;border-radius:4px;border:1px solid #bbb;background:#eee;cursor:pointer}
        .team-total{margin-top:8px;font-weight:600}
    </style>
</head>
<body>
    <div class="container">
        <section id="recorded" class="panel">
            <h2>記録済みプレイヤー</h2>
            
            <div class="controls">
                <input id="name" placeholder="プロフィールID">
                <button id="joinBtn">追加</button>
            </div>
            <ul id="recordedList"></ul>
            <small>記録済みプレイヤーをクリックしてキューに追加します。</small>
        </section>

        <section id="joining" class="panel">
            <h2>キュー</h2>
            <ul id="queueList"></ul>
            <div style="margin-top:8px" class="controls">
                <button id="sortBtn">チームに分ける</button>
                <button id="clearQueue">キューをクリア</button>
            </div>
        </section>

        <section id="team1" class="panel">
            <h2>チーム1</h2>
            <ul id="team1List"></ul>
            <div id="team1Total" class="team-total"></div>
        </section>

        <section id="team2" class="panel">
            <h2>チーム2</h2>
            <ul id="team2List"></ul>
            <div id="team2Total" class="team-total"></div>
        </section>
    </div>

    <script>
        const recorded = [];
        const queue = [];

        const recordedList = document.getElementById('recordedList');
        const queueList = document.getElementById('queueList');
        const team1List = document.getElementById('team1List');
        const team2List = document.getElementById('team2List');
        const team1Total = document.getElementById('team1Total');
        const team2Total = document.getElementById('team2Total');
        let currentTeam1 = [];
        let currentTeam2 = [];

        function renderRecorded(){
            recordedList.innerHTML = '';
            for(let i=0;i<recorded.length;i++){
                const p = recorded[i];
                const li = document.createElement('li');
                // Display explicit rating fields or 'N/A'; do not provide fallback values here
                const solo = (p.eloSolo!=null) ? p.eloSolo : 'N/A';
                const two = (p.elo2v2!=null) ? p.elo2v2 : 'N/A';
                const three = (p.elo3v3!=null) ? p.elo3v3 : 'N/A';
                const four = (p.elo4v4!=null) ? p.elo4v4 : 'N/A';

                const infoSpan = document.createElement('span');
                infoSpan.textContent = `${p.name} — 1v1:${solo} | 2v2:${two} | 3v3:${three} | 4v4:${four}`;
                infoSpan.style.cursor = 'pointer';
                infoSpan.addEventListener('click',()=>{
                    // Do not add duplicate queued entries when the same profile ID already exists in queue
                    if(p.id != null && queue.some(q => q && q.id != null && q.id === p.id)) return;
                    const copy = {...p};
                    queue.push(copy);
                    renderQueue();
                });

                // Alias (custom display name) input for the recorded player
                const aliasInput = document.createElement('input');
                aliasInput.type = 'text';
                aliasInput.placeholder = '別名';
                aliasInput.value = p.customName != null ? p.customName : '';
                aliasInput.style.marginLeft = '8px';
                aliasInput.addEventListener('click', e=> e.stopPropagation());
                aliasInput.addEventListener('change', e=>{
                    e.stopPropagation();
                    const v = String(e.target.value).trim();
                    if(v === ''){ delete p.customName; } else { p.customName = v; }
                    renderRecorded();
                });

                const removeBtn = document.createElement('button');
                removeBtn.textContent = '削除';
                removeBtn.dataset.i = String(i);
                removeBtn.addEventListener('click', e=>{
                    e.stopPropagation();
                    const idx = +e.target.dataset.i;
                    // Remove the recorded entry from `recorded`
                    const removed = recorded.splice(idx,1)[0];
                    // Also remove any queued copies that reference the same profile id or name
                    if(removed){
                        for(let qi = queue.length - 1; qi >= 0; qi--){
                            const q = queue[qi];
                            if(removed.id != null && q.id != null){
                                if(q.id === removed.id) queue.splice(qi,1);
                            } else if(removed.id == null){
                                if(q.name === removed.name) queue.splice(qi,1);
                            }
                        }
                    }
                    renderRecorded();
                    renderQueue();
                });

                li.appendChild(infoSpan);
                li.appendChild(aliasInput);
                li.appendChild(removeBtn);
                recordedList.appendChild(li);
            }
            // Save recorded entries (ids + custom aliases) to cookie after rendering
            saveRecordedToCookie();
        }

        function renderQueue(){
            queueList.innerHTML = '';
                // Infer match type from queue length for display: 4→2v2, 6→3v3, 8→4v4
                const qlen = queue.length;
                const matchTypeUsed = getInferredMatchType(qlen);
                for(let i=0;i<queue.length;i++){
                    const p = queue[i];
                    // Only display ELO when a match type can be inferred (queue lengths 4, 6, 8)
                    const baseElo = matchTypeUsed ? (pickElo(p, matchTypeUsed) ?? (p.eloSolo!=null ? p.eloSolo : null)) : null;
                    // customElo overrides team/solo ratings when set and non-zero
                    const useCustom = (p.customElo!=null && Number(p.customElo) !== 0);
                    const eloVal = useCustom ? Number(p.customElo) : baseElo;
                    const displayElo = eloVal!=null ? eloVal : '—';
                    const li = document.createElement('li');
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = p.name + (matchTypeUsed ? ' — ' + displayElo : '');
                    const customInput = document.createElement('input');
                    customInput.type = 'number';
                    customInput.placeholder = 'カスタムELO';
                    customInput.value = p.customElo != null ? p.customElo : '';
                    customInput.style.width = '80px';
                    customInput.style.marginLeft = '8px';
                    customInput.addEventListener('change', e=>{
                        const v = Number(e.target.value);
                        if(Number.isNaN(v) || v===0){ delete p.customElo; } else { p.customElo = v; }
                        renderQueue();
                    });
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = '削除'; removeBtn.dataset.i = String(i);
                    removeBtn.addEventListener('click', e=>{ const idx = +e.target.dataset.i; queue.splice(idx,1); renderQueue(); });
                    li.appendChild(nameSpan);
                    li.appendChild(customInput);
                    li.appendChild(removeBtn);
                    queueList.appendChild(li);
                }
        }

        function renderTeams(t1,t2){
                    team1List.innerHTML=''; team2List.innerHTML='';
                    let s1=0,s2=0;
                    // persist current teams so drag/drop can modify them
                    currentTeam1 = t1.slice();
                    currentTeam2 = t2.slice();
                    // render team1
                    for(let i=0;i<currentTeam1.length;i++){
                        const p = currentTeam1[i];
                        const li = document.createElement('li');
                        li.textContent = `${p.name} — ${p.elo}`;
                        li.draggable = true;
                        li.dataset.from = 'team1';
                        li.dataset.index = String(i);
                        li.addEventListener('dragstart', e=>{
                            e.dataTransfer.setData('application/json', JSON.stringify({from: 'team1', index: i}));
                        });
                        team1List.appendChild(li);
                        s1+=p.elo;
                    }
                    // render team2
                    for(let i=0;i<currentTeam2.length;i++){
                        const p = currentTeam2[i];
                        const li = document.createElement('li');
                        li.textContent = `${p.name} — ${p.elo}`;
                        li.draggable = true;
                        li.dataset.from = 'team2';
                        li.dataset.index = String(i);
                        li.addEventListener('dragstart', e=>{
                            e.dataTransfer.setData('application/json', JSON.stringify({from: 'team2', index: i}));
                        });
                        team2List.appendChild(li);
                        s2+=p.elo;
                    }
                    team1Total.textContent = `合計ELO: ${s1}`;
                    team2Total.textContent = `合計ELO: ${s2}`;
        }

        // Allow dropping between teams and from/to queue
        function handleDropOnTeam(target){
            return function(e){
                e.preventDefault();
                try{
                    const raw = e.dataTransfer.getData('application/json');
                    if(!raw) return;
                    const obj = JSON.parse(raw);
                    // moving from team1/team2
                    if(obj.from === 'team1' || obj.from === 'team2'){
                        const src = obj.from === 'team1' ? currentTeam1 : currentTeam2;
                        const srcIdx = Number(obj.index);
                        if(!Number.isFinite(srcIdx)) return;
                        const player = src.splice(srcIdx,1)[0];
                        const dst = target === 'team1' ? currentTeam1 : currentTeam2;
                        dst.push(player);
                    } else if(obj.from === 'queue'){
                        const qIdx = Number(obj.index);
                        if(!Number.isFinite(qIdx)) return;
                        const player = queue.splice(qIdx,1)[0];
                        // compute elo for player when moved from queue
                        const custom = (player.customElo!=null && Number(player.customElo)!==0) ? Number(player.customElo) : null;
                        const val = custom != null ? custom : (pickElo(player, getInferredMatchType(queue.length)) ?? (player.eloSolo!=null ? player.eloSolo : null));
                        const elo = (val!=null ? val : 0);
                        const dst = target === 'team1' ? currentTeam1 : currentTeam2;
                        dst.push({...player, elo});
                    }
                    renderTeams(currentTeam1, currentTeam2);
                    renderQueue();
                }catch(err){ console.warn('drop failed',err); }
            };
        }

        // allow dragging a team member back to the queue
        function handleDropOnQueue(e){
            e.preventDefault();
            try{
                const raw = e.dataTransfer.getData('application/json');
                if(!raw) return;
                const obj = JSON.parse(raw);
                if(obj.from === 'team1' || obj.from === 'team2'){
                    const src = obj.from === 'team1' ? currentTeam1 : currentTeam2;
                    const srcIdx = Number(obj.index);
                    if(!Number.isFinite(srcIdx)) return;
                    const player = src.splice(srcIdx,1)[0];
                    // push back to queue without the computed elo field
                    const cleaned = { ...player };
                    delete cleaned.elo;
                    queue.push(cleaned);
                    renderTeams(currentTeam1, currentTeam2);
                    renderQueue();
                }
            }catch(err){ console.warn('drop to queue failed',err); }
        }

        // attach drop handlers to lists (backwards-compatible)
        team1List.addEventListener('dragover', e=> e.preventDefault());
        team2List.addEventListener('dragover', e=> e.preventDefault());
        queueList.addEventListener('dragover', e=> e.preventDefault());
        team1List.addEventListener('drop', handleDropOnTeam('team1'));
        team2List.addEventListener('drop', handleDropOnTeam('team2'));
        queueList.addEventListener('drop', handleDropOnQueue);

        // Also attach handlers to the entire panel columns so the whole column is a drop zone
        const team1Panel = document.getElementById('team1');
        const team2Panel = document.getElementById('team2');
        const joiningPanel = document.getElementById('joining');
        if(team1Panel){ team1Panel.addEventListener('dragover', e=> e.preventDefault()); team1Panel.addEventListener('drop', handleDropOnTeam('team1')); }
        if(team2Panel){ team2Panel.addEventListener('dragover', e=> e.preventDefault()); team2Panel.addEventListener('drop', handleDropOnTeam('team2')); }
        if(joiningPanel){ joiningPanel.addEventListener('dragover', e=> e.preventDefault()); joiningPanel.addEventListener('drop', handleDropOnQueue); }

        function pickElo(p, matchType){
            // matchType: '2v2'|'3v3'|'4v4'
            // Return the exact team rating for the given match type, or null if unavailable (no fallback)
            if(!p) return null;
            if(matchType==='2v2') return (p.elo2v2!=null ? p.elo2v2 : null);
            if(matchType==='3v3') return (p.elo3v3!=null ? p.elo3v3 : null);
            if(matchType==='4v4') return (p.elo4v4!=null ? p.elo4v4 : null);
            return null;
        }

        function getInferredMatchType(qlen){
            if(qlen===4) return '2v2';
            if(qlen===6) return '3v3';
            if(qlen===8) return '4v4';
            return null;
        }

        document.getElementById('joinBtn').addEventListener('click',()=>{
            const name = document.getElementById('name').value.trim();
                if(!name) return alert('プロフィールIDを入力してください');
            // Treat numeric input as a profile ID and fetch data; otherwise add a manual recorded entry
            if(/^[0-9]+$/.test(name)){
                fetchAndAdd(name);
                document.getElementById('name').value='';
                return;
            }
            const p = {name};
            // add to recorded only (do not auto-add to queue)
            recorded.push(p);
            renderRecorded();
            document.getElementById('name').value='';
        });

        // Note: fetching is triggered via the Join button for numeric profile IDs.

        // Fetch player data from API and return a normalized player object (does not modify `recorded`)
        async function fetchPlayer(profileId){
            const url = `https://aoe4world.com/api/v0/players/${profileId}`;
            try{
                const res = await fetch(url);
                if(!res.ok) throw new Error('Fetch failed');
                const data = await res.json();
                function numeric(v){ return (typeof v==='number' && !Number.isNaN(v)) ? v : null; }
                function getEloField(dataObj, fieldName, modeKeys=[]){
                    if(dataObj && (fieldName in dataObj)) return numeric(dataObj[fieldName]);
                    if(dataObj && dataObj.modes && Array.isArray(modeKeys)){
                        for(const k of modeKeys){
                            if(k in dataObj.modes && dataObj.modes[k] && typeof dataObj.modes[k].rating === 'number'){
                                return dataObj.modes[k].rating;
                            }
                        }
                    }
                    return null;
                }
                return {
                    id: (data.profile_id || Number(profileId)),
                    name: data.name || `#${profileId}`,
                    eloSolo: getEloField(data, 'rm_1v1_elo', ['rm_1v1_elo']),
                    elo2v2: getEloField(data, 'rm_2v2_elo', ['rm_2v2_elo']),
                    elo3v3: getEloField(data, 'rm_3v3_elo', ['rm_3v3_elo']),
                    elo4v4: getEloField(data, 'rm_4v4_elo', ['rm_4v4_elo'])
                };
            }catch(err){
                console.warn('fetchPlayer failed for',profileId,err);
                return null;
            }
        }

        // Fetch a player by profile ID and upsert into `recorded` (does not auto-queue)
        async function fetchAndAdd(profileId){
            const p = await fetchPlayer(profileId);
            if(!p) return;
            const existingIndex = recorded.findIndex(r => r.id && p.id && r.id === p.id);
            if(existingIndex >= 0){
                recorded[existingIndex] = { ...recorded[existingIndex], ...p };
            } else {
                recorded.push(p);
            }
            // Do NOT auto-add to queue when fetching — only update recorded list
            renderRecorded(); renderQueue();
        }

        // Persist recorded players (id and customName) to a cookie for later reload
        function saveRecordedToCookie(){
            try{
                // only persist entries that have an id (we fetch name from API on load)
                const data = recorded.filter(p=>p.id!=null).map(p=>({ id: p.id, customName: p.customName || null }));
                const json = encodeURIComponent(JSON.stringify(data));
                // expire in 1 year
                document.cookie = `aoe4_recorded=${json};path=/;max-age=${60*60*24*365}`;
            }catch(e){
                console.warn('Could not save recorded to cookie',e);
            }
        }

        // Load recorded player IDs from cookie and refresh `recorded` by fetching current data
        async function loadRecordedFromCookie(){
            try{
                const match = document.cookie.split('; ').find(row=>row.startsWith('aoe4_recorded='));
                if(!match) return;
                const json = decodeURIComponent(match.split('=')[1] || '');
                if(!json) return;
                const arr = JSON.parse(json);
                if(!Array.isArray(arr)) return;
                // collect ids and fetch concurrently
                const ids = arr.filter(it => it && it.id).map(it => it.id);
                const fetchPromises = ids.map(id => fetchPlayer(id));
                const results = await Promise.all(fetchPromises);
                // upsert results and reapply aliases from cookie data
                for(const p of results){
                    if(!p) continue;
                    const existingIndex = recorded.findIndex(r => r.id && p.id && r.id === p.id);
                    if(existingIndex >= 0){ recorded[existingIndex] = { ...recorded[existingIndex], ...p }; }
                    else { recorded.push(p); }
                    const cookieItem = arr.find(it => Number(it.id) === Number(p.id));
                    if(cookieItem && cookieItem.customName){
                        const idx = recorded.findIndex(r => r.id && r.id === p.id);
                        if(idx>=0) recorded[idx].customName = cookieItem.customName;
                    }
                }
                renderRecorded();
            }catch(e){ console.warn('Could not load recorded from cookie',e); }
        }

        // Note: Ratings are read only from explicit `rm_*_elo` fields; no fallback rating logic is used.

        document.getElementById('clearQueue').addEventListener('click',()=>{ queue.length=0; renderQueue(); renderTeams([],[]); });

        document.getElementById('sortBtn').addEventListener('click',()=>{
            // Determine match type from queue length: 4→2v2, 6→3v3, 8→4v4 (auto only)
            const qlen = queue.length;
            const matchTypeUsed = getInferredMatchType(qlen);
            if(!matchTypeUsed){ alert('チーム分けするにはキューの人数が正確に4、6、または8である必要があります'); return; }

            // Recompute ELO for each queued player based on the inferred match type.
            // Missing ratings default to 0 so balancing works predictably.
            const players = queue.map(p=>{
                // customElo (if set and non-zero) overrides the team/solo rating for sorting
                const custom = (p.customElo!=null && Number(p.customElo)!==0) ? Number(p.customElo) : null;
                const val = custom != null ? custom : (pickElo(p, matchTypeUsed) ?? (p.eloSolo!=null ? p.eloSolo : null));
                return { ...p, elo: (val!=null ? val : 0) };
            });

            // For small player counts, perform an exhaustive search for the partition
            // that minimizes the absolute difference in total ELO between teams.
            const total = players.reduce((s,p)=>s+p.elo,0);
            const teamSize = players.length / 2;

            function combinations(n,k){
                const res = [];
                const combo = [];
                function helper(start){
                    if(combo.length === k){ res.push(combo.slice()); return; }
                    for(let i = start; i < n; i++){
                        combo.push(i);
                        helper(i+1);
                        combo.pop();
                    }
                }
                helper(0);
                return res;
            }

            let bestCombo = null;
            let bestDiff = Infinity;

            const combs = combinations(players.length, teamSize);
            for(const combo of combs){
                const s1 = combo.reduce((s,i)=>s + players[i].elo, 0);
                const s2 = total - s1;
                const diff = Math.abs(s1 - s2);
                if(diff < bestDiff){ bestDiff = diff; bestCombo = combo.slice(); }
            }

            let t1 = [], t2 = [];
            if(bestCombo){
                const set = new Set(bestCombo);
                for(let i=0;i<players.length;i++){
                    if(set.has(i)) t1.push(players[i]); else t2.push(players[i]);
                }
            } else {
                // Fallback (shouldn't happen) to greedy assignment
                players.sort((a,b)=> b.elo - a.elo);
                let s1=0,s2=0;
                for(const p of players){ if(s1<=s2){ t1.push(p); s1+=p.elo; } else { t2.push(p); s2+=p.elo; } }
            }

            renderTeams(t1,t2);
        });

        // Initial render: load saved recorded players from cookie (if any), then render UIs
        loadRecordedFromCookie().then(()=>{ renderQueue(); renderTeams([],[]); }).catch(()=>{ renderRecorded(); renderQueue(); renderTeams([],[]); });
    </script>
</body>
</html>